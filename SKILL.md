---
name: repo2doc
description: 将代码仓库整理为结构化项目文档（非报告）。通过规范驱动的写作指南，生成可读、可落地、可维护的项目文档。
---

# repo2doc

把仓库输出为"可读、可落地、可维护"的项目文档，不是分析报告。

## 核心原则

1. **规范驱动，而非模板填充** - 不提供固定模板，而是定义写作规范，让内容根据项目实际情况自然生长
2. **读者优先** - 文档面向需要理解和使用该项目的人，不是生成过程的记录
3. **实现导向** - 所有描述必须落到真实代码，禁止泛化描述
4. **结构清晰** - 固定文档主线，但允许根据项目特点调整章节组织

## 文档主线（固定）

文档必须按以下主线组织：

1. 项目总览
2. 入门指南（安装与配置）
3. 功能概括
4. 功能点 1（实现细节 + 设计原理）
5. 功能点 2（实现细节 + 设计原理）
6. 以此类推

## 输入参数

执行前明确：

- 仓库来源：Git URL 或本地路径
- 目标版本：branch/tag/commit（默认分支）
- 输出目录：默认 `Report/<ProjectName>/`
- 深度模式：`standard` 或 `audit`
- 输出语言：`zh`（中文，默认）或 `en`（英文）

## 输出文件结构

```
Report/<ProjectName>/
├── 00-reading-guide.md      # 文档导航
├── project-overview.md      # 项目总览
├── getting-started.md       # 安装、配置、启动
├── feature-summary.md       # 功能概括
└── <module-name>.md         # 一个或多个模块文档
```

---

## 文档写作规范

### 通用格式规范

#### 标题层级
- 一级标题（`#`）：文档标题，每文档仅一个
- 二级标题（`##`）：主要章节
- 三级标题（`###`）：子章节
- 四级标题（`####`）：模块子章节

#### 语言风格
- **主动语态**：使用"系统通过...实现"而非"...被实现"
- **现在时态**：描述当前实现，不使用过去时
- **对读者称 "你"**："你可以配置..."，禁用 "我/我们/咱们"
- **简洁直接**：避免冗长前缀，直击要点

#### 代码规范
- 代码块必须标注语言（` ```rust `、` ```go `）
- 命令示例不含 `$` 提示符
- 命令与输出分离，或用注释说明
- 行内代码用反引号：`` `function_name` ``

#### 链接规范
- 同目录文件：相对路径 `[模块文档](./module.md)`
- 外部资源：完整 URL
- 避免使用 "点击这里"，链接文本应有描述性

---

### 1. project-overview.md（项目总览）

**目的**：让读者在 5 分钟内理解项目是什么、解决什么问题、是否适合自己。

**必须包含的章节**：

#### 1.1 项目定位
- **一句话描述**：项目解决的核心问题（电梯演讲长度）
- **目标用户**：谁应该用这个项目
- **核心场景**：2-3 个典型使用场景
- **差异化**：与同类项目相比的核心差异

#### 1.2 架构总览
- **架构图**：文本示意图或 mermaid 图
- **关键数据流**：请求/数据如何在各组件间流转
- **分层说明**：入口层 → 业务层 → 数据层 → 基础设施层

#### 1.3 关键目录说明
| 目录 | 说明 | 对应职责 |
|------|------|----------|
| `src/` | 源代码主目录 | 核心业务实现 |
| ... | ... | ... |

#### 1.4 技术栈
- 语言及版本要求
- 构建工具
- 核心依赖及用途

**写作要点**：
- 不要罗列所有功能，聚焦"为什么存在这个项目"
- 架构图用文本即可，不需要精美图形
- 技术栈说明为什么选择这些技术（如果理由不明显）

---

### 2. getting-started.md（入门指南）

**目的**：让新用户在 15 分钟内跑起来。

**必须包含的章节**：

#### 2.1 环境要求
| 依赖 | 版本 | 必需/可选 | 说明 |
|------|------|-----------|------|
| Rust | 1.70+ | 必需 | 编译运行所需 |
| ... | ... | ... | ... |

#### 2.2 安装步骤
- **从源码安装**：克隆 → 编译 → 安装（如有）
- **包管理器安装**：cargo/npm/apt 等（如支持）
- **预编译二进制**：下载链接（如提供）

#### 2.3 配置说明
- 配置文件位置（全局/项目级）
- 最小可运行配置示例
- 关键配置项说明

#### 2.4 验证安装
- 启动命令
- 验证命令（版本检查、健康检查）
- 运行测试（如有）

#### 2.5 常见问题（可选但推荐）
- 编译失败的常见原因
- 运行时错误的解决方法

**写作要点**：
- 步骤必须可复现，假设读者只有基础环境
- 提供复制粘贴即可运行的命令
- 错误处理要具体，不要"检查配置"这种模糊建议

---

### 3. feature-summary.md（功能概括）

**目的**：给读者一个功能全景图，知道项目能做什么。

**必须包含的章节**：

#### 3.1 功能清单
| 功能 | 说明 | 状态 | 对应模块 |
|------|------|------|----------|
| 网络穿透 | 实现 NAT 穿透，建立 P2P 连接 | 稳定 | network, peer |
| ... | ... | ... | ... |

#### 3.2 功能分层
- **用户层**：CLI/API/界面提供的功能
- **业务逻辑层**：核心算法、协议实现
- **基础设施层**：存储、网络、工具类

#### 3.3 典型流程
- 用编号列表描述 2-3 个典型使用流程
- 说明用户操作 → 系统处理 → 结果返回的完整链条

#### 3.4 功能依赖（可选）
- 文本示意图展示功能间的依赖关系

**写作要点**：
- 功能描述用动词开头（"实现..."、"提供..."、"支持..."）
- 状态标注：稳定/开发中/实验性
- 不要在此展开实现细节，那是模块文档的工作

---

### 4. <module>.md（模块文档）

**目的**：深入理解特定模块的实现细节和设计决策。

**必须包含的章节**：

#### 4.1 模块定位
- 该模块在整体架构中的位置
- 承担的核心职责
- 与上下游模块的关系

#### 4.2 功能概括
| 功能点 | 一句话描述 |
|--------|------------|
| 连接管理 | 建立和维护对等节点连接 |
| ... | ... |

#### 4.3 功能点：<具体名称>

每个功能点一个二级标题，格式：`## 功能点：XXX`

##### 实现细节
- 入口点/对外接口（函数/方法签名）
- 核心算法或处理流程
- 关键数据结构
- 状态管理策略

##### 设计原理
- 为什么这样设计
- 权衡了哪些方案（对比说明）
- 解决了什么核心问题
- 潜在限制和假设

##### 关键代码片段
```rust
// 5-30 行核心实现代码
// 需包含：函数签名、关键逻辑、错误处理
// 配合注释说明设计意图
```

##### 涉及模块

**必须**展开为逐模块子章节，格式：`#### 模块：<模块名>`

每个模块子章节必须包含：

- **职责**：该模块在本功能点中承担的具体职责（一句话 + 扩展说明）
- **实现细节**：该模块如何配合实现该功能（接口调用、数据流转、状态变更）
- **设计原理**：该模块的设计决策依据（为什么这样实现，权衡了哪些方案）
- **协作关系**：与当前模块的调用/被调用关系，数据流向

**模块子章节示例**：

```markdown
#### 模块：network

- **职责**：负责底层网络连接的管理，包括 TCP/UDP 连接的建立、维护和断开

- **实现细节**：
  - 使用 `Connector` trait 抽象不同传输协议
  - 连接池管理活跃连接，通过 `PeerManager` 统一调度
  - 心跳机制每 30 秒检测连接健康状态

- **设计原理**：
  - 采用 trait 抽象而非枚举，便于后续扩展新协议（如 QUIC）
  - 连接池设计参考了数据库连接池模式，平衡资源占用与连接延迟

- **协作关系**：
  - 被 `PeerManager` 调用创建新连接
  - 向上层 `Tunnel` 接口提供字节流传输能力
  - 与 `crypto` 模块协作完成握手后的加密传输
```

**写作要点**：
- 功能点必须具体到可对应代码（如"连接管理"而非"网络功能"）
- 设计原理要回答"为什么"，不是"是什么"
- 代码片段要配合文字说明，不要只贴代码
- 跨模块功能必须把涉及的每个模块单独写成子章节，不能合并一句话带过

---

## 写作检查清单

### 通用检查
- [ ] 文档正文不出现"本报告"、"本文档由...生成"等过程性描述
- [ ] 无空章节、占位标题、TODO
- [ ] 所有描述落到真实代码，可追溯到具体文件/函数
- [ ] 代码块标注语言，命令无 `$` 提示符

### 项目总览检查
- [ ] 能用一句话说明项目解决什么问题
- [ ] 架构图展示了主要组件关系
- [ ] 目录说明对应到具体职责

### 入门指南检查
- [ ] 步骤从克隆/下载到验证完整可复现
- [ ] 环境要求列出版本号
- [ ] 提供了最小可运行配置

### 功能概括检查
- [ ] 功能清单覆盖主要能力
- [ ] 每个功能有对应模块标注
- [ ] 典型流程描述了完整用户旅程

### 模块文档检查
- [ ] 每个功能点有独立章节（`## 功能点：XXX`）
- [ ] 每个功能点包含"实现细节"和"设计原理"
- [ ] 每个功能点包含代码片段
- [ ] "涉及模块"下有至少一个 `#### 模块：XXX` 子章节
- [ ] 每个模块子章节包含：职责、实现细节、设计原理、协作关系

---

## 使用流程

### 步骤 1：发现模块

```bash
scripts/discover-modules.sh <repo-path> --top 6 --format csv
```

### 步骤 2：创建文档目录

```bash
mkdir -p Report/<ProjectName>
```

### 步骤 3：分析模块（辅助理解）

```bash
scripts/analyze-module.sh <repo-path> <module-name> --output-format markdown
```

### 步骤 4：按规范写作

按顺序创建文档：

1. `project-overview.md` - 阅读 README、Cargo.toml/go.mod 等，提炼项目定位
2. `getting-started.md` - 检查构建脚本、CI 配置、文档中的安装说明
3. `feature-summary.md` - 基于目录结构和主要模块推断功能分层
4. `<module>.md` - 深入源码，按"功能点"组织内容

### 步骤 5：校验

```bash
scripts/validate-report.sh <ProjectName> --strict --depth-profile audit --enforce
```

---

## 深度模式定义

### standard（标准模式）

- 模块文档 >= 1
- 每个模块文档功能点章节 >= 2
- 不强制要求代码片段
- 不强制要求模块子章节的完整性

### audit（审计模式）

- 模块文档 >= 2
- 每个模块文档功能点章节 >= 3
- 强制要求每个功能点有代码片段
- 强制要求每个功能点有"涉及模块"及逐模块子章节
- **强制要求每个"模块："子章节包含"实现细节"和"设计原理"**

---

## 常见错误避免

1. **不要把分析报告当文档** - 删除所有"本报告""本文档由"等过程性描述
2. **不要留空章节** - 每个功能点必须有实质内容
3. **不要合并模块描述** - 跨模块功能要逐个模块展开
4. **不要只贴代码不解释** - 代码片段需配合设计原理说明
5. **不要省略模块子章节的四要素** - 职责、实现细节、设计原理、协作关系缺一不可
6. **不要把"涉及模块"写成列表** - 必须展开为 `#### 模块：XXX` 子章节形式
7. **不要用模板语言填充** - 根据项目实际情况写作，不是填空
